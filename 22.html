<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Particle System - Green Glow Overlay</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050b05; }
        #canvas-container { 
            width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 2;
        }
        #video-bg {
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            object-fit: cover;
            z-index: 1;
            pointer-events: none;
        }
        #video-container { 
            position: absolute; bottom: 20px; left: 20px; z-index: 3;
            border: 2px solid rgba(0, 255, 62, 0.34); 
            border-radius: 8px; overflow: hidden;
            box-shadow: 0 0 22px rgba(59, 255, 155, 0.43);
        }
        video { width: 200px; height: 150px; transform: scaleX(-1); display: block; }
        #loading { 
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); 
            color: #5cff3d; font-family: 'Arial', sans-serif; font-size: 1.2rem;
            text-align: center; z-index: 10; pointer-events: none;
            text-shadow: 0 0 22px #49fc69;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="loading">
        系统正在初始化...<br>
        <span style="font-size:0.8em; color:#aaa;">请允许摄像头权限以启用手势控制</span>
    </div>
    <video id="video-bg" autoplay muted playsinline></video>
    <div id="video-container">
        <video id="input_video"></video>
    </div>
    <div id="canvas-container"></div>

<script>
    // 绿色荧光参数和颜色区
    const CONFIG = {
        particleCount: 28000,
        particleSize: 8,
        canvasWidth: 800,
        canvasHeight: 400,
        depth: 55,
        grabThreshold: 0.15,
        colors: [
            new THREE.Color('#0a5f0a'),     // 左：深绿
            new THREE.Color('#39ff5a'),     // 右：鲜亮绿
            new THREE.Color('#c7ffe6')      // 高亮：浅荧光绿
        ]
    };

    let scene, camera, renderer, particleSystem, particleGroup;
    let targetPositions = [];
    let currentPositions = [];
    let originalColors = [];
    let state = {
        expansion: 0,
        text: "Hello",
        isDragging: false,
        handStartPos: new THREE.Vector3(),
        groupStartPos: new THREE.Vector3(),
        handStartAngle: 0,
        groupStartAngle: 0,
        time: 0
    };

    function initThree() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x1f5530, 0.0016); // 绿色雾更明显

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000);
        camera.position.z = 400;

        renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        // 荧光绿色glow
        const sprite = getGlowTexture();
        const material = new THREE.PointsMaterial({
            size: CONFIG.particleSize,
            map: sprite,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 1
        });

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const colors = new Float32Array(CONFIG.particleCount * 3);

        for (let i = 0; i < CONFIG.particleCount; i++) {
            const x = (Math.random() - 0.5) * 1000;
            const y = (Math.random() - 0.5) * 1000;
            const z = (Math.random() - 0.5) * 1000;

            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;

            currentPositions.push({ x, y, z });
            targetPositions.push({ x, y, z, active: false });

            // 深绿初始
            const color = new THREE.Color('#157d15');
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        particleSystem = new THREE.Points(geometry, material);

        particleGroup = new THREE.Group();
        particleGroup.add(particleSystem);
        scene.add(particleGroup);

        updateTextParticles(state.text);
        window.addEventListener('resize', onWindowResize, false);
    }

    function getGlowTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 48;
        canvas.height = 48;
        const ctx = canvas.getContext('2d');
        // 辐射绿色激光的Glow
        const gradient = ctx.createRadialGradient(24, 24, 0, 24, 24, 24);
        gradient.addColorStop(0, 'rgba(160,255,160,1)');
        gradient.addColorStop(0.33, 'rgba(80,255,144,0.75)');
        gradient.addColorStop(0.7,  'rgba(32,255,159,0.13)');
        gradient.addColorStop(1,   'rgba(0,0,0,0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 48, 48);
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    function updateTextParticles(text) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = CONFIG.canvasWidth;
        canvas.height = CONFIG.canvasHeight;
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        let fontSize = 120;
        ctx.font = `bold ${fontSize}px "Microsoft YaHei", Arial, sans-serif`;
        ctx.fillStyle = '#ffffff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        const maxLineWidth = canvas.width * 0.9;
        const lines = [];
        let currentLine = text[0];

        for (let i = 1; i < text.length; i++) {
            const char = text[i];
            const width = ctx.measureText(currentLine + char).width;
            if (width < maxLineWidth) {
                currentLine += char;
            } else {
                lines.push(currentLine);
                currentLine = char;
            }
        }
        lines.push(currentLine);

        if (lines.length > 1) fontSize *= 0.68;
        if (lines.length > 2) fontSize *= 0.52;
        ctx.font = `bold ${fontSize}px "Microsoft YaHei", Arial, sans-serif`;

        const lineHeight = fontSize * 1.13;
        const totalHeight = lines.length * lineHeight;
        const startY = (canvas.height - totalHeight) / 2 + lineHeight / 2;

        lines.forEach((line, index) => {
            ctx.fillText(line, canvas.width / 2, startY + index * lineHeight);
        });

        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        let validPoints = [];
        const step = 1;

        for (let y = 0; y < canvas.height; y += step) {
            for (let x = 0; x < canvas.width; x += step) {
                const alpha = data[(y * canvas.width + x) * 4];
                if (alpha > 128) {
                    validPoints.push({
                        x: (x - canvas.width / 2) * 2,
                        y: -(y - canvas.height / 2) * 2,
                        z: 0
                    });
                }
            }
        }

        validPoints.sort(() => Math.random() - 0.5);
        for (let i = 0; i < CONFIG.particleCount; i++) {
            if (i < validPoints.length) {
                targetPositions[i] = {
                    x: validPoints[i].x,
                    y: validPoints[i].y,
                    z: 0,
                    active: true
                };
            } else {
                const angle = Math.random() * Math.PI * 2;
                const radius = 270 + Math.random() * 320;
                targetPositions[i] = {
                    x: Math.cos(angle) * radius,
                    y: Math.sin(angle) * radius,
                    z: (Math.random() - 0.5) * 180,
                    active: false
                };
            }
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        state.time += 0.01;

        const positions = particleSystem.geometry.attributes.position.array;
        const colors = particleSystem.geometry.attributes.color.array;
        let ease = 0.09;

        for (let i = 0; i < CONFIG.particleCount; i++) {
            const target = targetPositions[i];
            const current = currentPositions[i];
            let tx, ty, tz;

            if (target.active) {
                tx = target.x;
                ty = target.y;
                tz = target.z;
                if (state.expansion > 0.01) {
                    const len = Math.sqrt(tx*tx + ty*ty + 1);
                    const nx = tx / len;
                    const ny = ty / len;
                    const spread = state.expansion * 600;
                    const noiseX = Math.sin(state.time * 2 + ty * 0.01) * 31 * state.expansion;
                    const noiseY = Math.cos(state.time * 2 + tx * 0.01) * 31 * state.expansion;
                    tx += nx * spread + noiseX;
                    ty += ny * spread + noiseY;
                    tz += (Math.random()-0.5) * spread * 0.15;
                }
            } else {
                tx = target.x + Math.sin(state.time + i) * 12;
                ty = target.y + Math.cos(state.time + i * 0.5) * 11;
                tz = target.z;
                if(state.expansion > 0.1) {
                   tx *= (1 + state.expansion * 0.87);
                   ty *= (1 + state.expansion * 0.87);
                   tz *= (1 + state.expansion * 0.87);
                }
            }

            current.x += (tx - current.x) * ease;
            current.y += (ty - current.y) * ease;
            current.z += (tz - current.z) * ease;

            positions[i * 3] = current.x;
            positions[i * 3 + 1] = current.y;
            positions[i * 3 + 2] = current.z;

            // 绿色渐变+荧光增益
            let normalizeX = (current.x + 400) / 800;
            normalizeX = Math.max(0, Math.min(1, normalizeX));
            const colorA = CONFIG.colors[0];
            const colorB = CONFIG.colors[1];
            const colorH = CONFIG.colors[2];

            // 高光gain
            let highlight = Math.exp(-Math.pow(normalizeX-0.5,2)/0.10)*0.35;
            let r = colorA.r*(1-normalizeX)+colorB.r*normalizeX + colorH.r*highlight;
            let g = colorA.g*(1-normalizeX)+colorB.g*normalizeX + colorH.g*highlight;
            let b = colorA.b*(1-normalizeX)+colorB.b*normalizeX + colorH.b*highlight;

            let flash = state.expansion * 0.38;
            // 文字部分荧光极亮
            if (target.active) {
                g = Math.min(g + 1.15, 1);   // G主色最大
                r = Math.min(r + 0.45, 1);   // 少量R辅助
                b = Math.min(b + 0.18, 1);   // 微量B表现科技
            }
            colors[i * 3] = Math.min(r + flash, 1) * 0.88 + 0.12;
            colors[i * 3 + 1] = Math.min(g + flash, 1);   // G通道直接最大
            colors[i * 3 + 2] = Math.min(b + flash, 1) * 0.65 + 0.14;
        }

        particleSystem.geometry.attributes.position.needsUpdate = true;
        particleSystem.geometry.attributes.color.needsUpdate = true;
        if (!state.isDragging) {
            particleGroup.rotation.y += Math.sin(state.time * 0.5) * 0.0012;
            particleGroup.rotation.x *= 0.96;
            particleGroup.rotation.z *= 0.96;
        }
        renderer.render(scene, camera);
    }

    function onResults(results) {
        document.getElementById('loading').style.display = 'none';
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            const fingers = countFingers(landmarks);
            let nextText = state.text;
            if (fingers === 1) nextText = "全民制作人们大家好";
            else if (fingers === 2) nextText = "我是练习时长两年半的个人练习生";
            else if (fingers === 3) nextText = "我喜欢唱跳rap篮球";
	    else if (fingers === 4) nextText = "再多一眼就会爆炸";
            if (nextText !== state.text) {
                state.text = nextText;
                updateTextParticles(state.text);
            }
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const pinchDist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));
            let factor = (pinchDist - 0.05) * 4; 
            state.expansion = Math.max(0, Math.min(1, factor));
            const wrist = landmarks[0];
            const midBase = landmarks[9];
            if (state.expansion < 0.3) {
                const screenX = (1 - wrist.x) * 2 - 1; 
                const screenY = -(wrist.y * 2 - 1);
                if (!state.isDragging) {
                    state.isDragging = true;
                    state.handStartPos.set(screenX, screenY, 0);
                    state.groupStartPos.copy(particleGroup.position);
                    const dx = midBase.x - wrist.x;
                    const dy = midBase.y - wrist.y;
                    state.handStartAngle = Math.atan2(dy, dx);
                    state.groupStartAngle = particleGroup.rotation.y;
                } else {
                    const moveX = screenX - state.handStartPos.x;
                    const moveY = screenY - state.handStartPos.y;
                    particleGroup.position.x = state.groupStartPos.x + moveX * 600;
                    particleGroup.position.y = state.groupStartPos.y + moveY * 600;
                    const dx = midBase.x - wrist.x;
                    const dy = midBase.y - wrist.y;
                    const currentAngle = Math.atan2(dy, dx);
                    let angleDelta = currentAngle - state.handStartAngle;
                    if (angleDelta > Math.PI) angleDelta -= Math.PI * 2;
                    if (angleDelta < -Math.PI) angleDelta += Math.PI * 2;
                    particleGroup.rotation.y = state.groupStartAngle - angleDelta * 3;
                }
            } else {
                state.isDragging = false;
            }
        } else {
            state.expansion *= 0.9;
            state.isDragging = false;
        }
    }

    function countFingers(lm) {
        let count = 0;
        if (lm[8].y < lm[6].y) count++;
        if (lm[12].y < lm[10].y) count++;
        if (lm[16].y < lm[14].y) count++;
        if (lm[20].y < lm[18].y) count++;
        return count;
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        const videoBg = document.getElementById('video-bg');
        videoBg.style.width =  window.innerWidth + "px";
        videoBg.style.height = window.innerHeight + "px";
    }

    // 摄像头启动和两路画面同步
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });
    hands.onResults(onResults);

    const videoElement = document.getElementById('input_video');
    const videoBg = document.getElementById('video-bg');

    function startCamera() {
        navigator.mediaDevices.getUserMedia({video:true}).then(stream => {
            videoElement.srcObject = stream;
            videoBg.srcObject = stream;
            videoElement.play();
            videoBg.play();
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            cameraUtils.start();
        }).catch(err => {
            document.getElementById('loading').innerText = '摄像头初始化失败：' + err.message;
        });
    }

    initThree();
    animate();
    startCamera();

    window.addEventListener('resize', onWindowResize);
    window.onload = () => {
        videoBg.style.width =  window.innerWidth + "px";
        videoBg.style.height = window.innerHeight + "px";
    };
</script>
</body>
</html>